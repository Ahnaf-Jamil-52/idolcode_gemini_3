"""
Problem Intent Engine

Answers "Why this problem, for you, now?"

The engine assigns problems with deep pedagogical intent, not random selection.
Each problem choice has a reason grounded in:
- Weak skill targeting
- Trajectory alignment  
- Failure archetype correction
- Optimal difficulty progression
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Dict, Optional, Set, Any
from enum import Enum
import random


class SkillCategory(Enum):
    """Core algorithmic skill categories."""
    DYNAMIC_PROGRAMMING = "dp"
    GRAPH_ALGORITHMS = "graphs"
    GREEDY = "greedy"
    DATA_STRUCTURES = "data_structures"
    MATH = "math"
    STRING_ALGORITHMS = "strings"
    BINARY_SEARCH = "binary_search"
    TWO_POINTERS = "two_pointers"
    SORTING = "sorting"
    BIT_MANIPULATION = "bitmask"
    GEOMETRY = "geometry"
    NUMBER_THEORY = "number_theory"
    CONSTRUCTIVE = "constructive"
    IMPLEMENTATION = "implementation"


class CognitiveTrigger(Enum):
    """What mental challenge this problem poses."""
    FORCES_ABSTRACTION = "forces_abstraction"
    PUNISHES_GREEDY_INTUITION = "punishes_greedy_intuition"
    REQUIRES_OBSERVATION = "requires_observation"
    TESTS_EDGE_CASES = "tests_edge_cases"
    NEEDS_OPTIMIZATION = "needs_optimization"
    PATTERN_BREAKING = "pattern_breaking"
    STATE_COMPRESSION = "state_compression"
    TRANSITION_REUSE = "transition_reuse"
    CONSTRAINT_ANALYSIS = "constraint_analysis"
    INVARIANT_DISCOVERY = "invariant_discovery"


@dataclass
class ProblemMetadata:
    """
    Complete metadata for a problem, preprocessed once.
    Can be generated by LLM (Gemini) or manually curated.
    """
    problem_id: int
    title: str
    difficulty: int  # Codeforces-style rating (800-3500)
    
    # Skill taxonomy
    tags: List[str]  # e.g., ["dp", "bitmask"]
    hidden_skills: List[str]  # Skills not obvious from tags
    
    # Cognitive profile
    cognitive_triggers: List[CognitiveTrigger]
    
    # Failure patterns
    common_wrong_paths: List[str]  # Common mistakes users make
    failure_archetypes_targeted: List[str]  # Which archetypes this helps fix
    
    # Historical context (for trajectory matching)
    historical_role: str  # e.g., "tourist_breakthrough_problem", "stabilization_problem"
    typical_solve_time_minutes: int
    
    # Prerequisites
    required_skills: List[str]
    recommended_prerequisites: List[int]  # Other problem IDs to solve first
    
    # Metadata
    source: str = "codeforces"
    url: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "problem_id": self.problem_id,
            "title": self.title,
            "difficulty": self.difficulty,
            "tags": self.tags,
            "hidden_skills": self.hidden_skills,
            "cognitive_triggers": [t.value for t in self.cognitive_triggers],
            "common_wrong_paths": self.common_wrong_paths,
            "failure_archetypes_targeted": self.failure_archetypes_targeted,
            "historical_role": self.historical_role,
            "typical_solve_time_minutes": self.typical_solve_time_minutes,
            "required_skills": self.required_skills,
            "recommended_prerequisites": self.recommended_prerequisites,
            "source": self.source,
            "url": self.url,
        }


@dataclass
class UserSkillProfile:
    """User's skill assessment across categories."""
    user_id: str
    
    # Skill ratings (0-3500, like Codeforces rating)
    skill_ratings: Dict[str, int] = field(default_factory=dict)
    
    # Weak areas (need improvement)
    weak_skills: Set[str] = field(default_factory=set)
    
    # Strong areas (can handle harder problems)
    strong_skills: Set[str] = field(default_factory=set)
    
    # Avoidance patterns (tags user dodges)
    avoided_tags: Set[str] = field(default_factory=set)
    
    # Current trajectory phase
    trajectory_phase: str = "foundation"  # foundation, growth, mastery, expert
    
    # Overall rating
    current_rating: int = 1200
    
    # Recent performance
    recent_problems_solved: List[int] = field(default_factory=list)
    recent_problems_failed: List[int] = field(default_factory=list)


@dataclass
class ReasonVector:
    """
    The complete reasoning for why a problem is assigned.
    This is used to generate the explanation.
    """
    weak_skill_match: bool
    targeted_skill: Optional[str]
    
    trajectory_alignment: str  # e.g., "tourist_phase_2", "stability_building"
    
    failure_archetype_targeted: Optional[str]
    archetype_correction_method: Optional[str]
    
    difficulty_gap: int  # Relative to user's current rating
    difficulty_justification: str
    
    # Historical context
    similar_champion_problem: Optional[str]
    
    # Strategic intent
    strategic_goal: str  # "break_through_plateau", "build_confidence", "fill_gap"
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "weak_skill_match": self.weak_skill_match,
            "targeted_skill": self.targeted_skill,
            "trajectory_alignment": self.trajectory_alignment,
            "failure_archetype_targeted": self.failure_archetype_targeted,
            "archetype_correction_method": self.archetype_correction_method,
            "difficulty_gap": self.difficulty_gap,
            "difficulty_justification": self.difficulty_justification,
            "similar_champion_problem": self.similar_champion_problem,
            "strategic_goal": self.strategic_goal,
        }


class ProblemIntentEngine:
    """
    The core engine that decides which problem to assign and why.
    
    This is NOT random problem selection. Every assignment has intent.
    """
    
    def __init__(self, problem_database: List[ProblemMetadata], 
                 use_gemini: bool = False,
                 gemini_api_key: Optional[str] = None):
        """
        Args:
            problem_database: List of problems with full metadata
            use_gemini: Whether to use Gemini for explanation generation
            gemini_api_key: Gemini API key
        """
        self.problems = {p.problem_id: p for p in problem_database}
        self.use_gemini = use_gemini
        self.gemini_api_key = gemini_api_key
        
        # Index problems by various dimensions for fast lookup
        self._build_indices()
        
    def _build_indices(self):
        """Build indices for efficient problem selection."""
        self.by_difficulty: Dict[int, List[int]] = {}
        self.by_tag: Dict[str, List[int]] = {}
        self.by_archetype: Dict[str, List[int]] = {}
        
        for pid, problem in self.problems.items():
            # Difficulty buckets (100-point ranges)
            difficulty_bucket = (problem.difficulty // 100) * 100
            if difficulty_bucket not in self.by_difficulty:
                self.by_difficulty[difficulty_bucket] = []
            self.by_difficulty[difficulty_bucket].append(pid)
            
            # Tag indices
            for tag in problem.tags:
                if tag not in self.by_tag:
                    self.by_tag[tag] = []
                self.by_tag[tag].append(pid)
            
            # Archetype indices
            for archetype in problem.failure_archetypes_targeted:
                if archetype not in self.by_archetype:
                    self.by_archetype[archetype] = []
                self.by_archetype[archetype].append(pid)
    
    def select_problem(self, 
                      user_profile: UserSkillProfile,
                      current_archetype: Optional[str] = None,
                      strategic_goal: str = "optimal_growth") -> tuple[ProblemMetadata, ReasonVector]:
        """
        Select the optimal next problem for this user.
        
        Args:
            user_profile: User's skill profile
            current_archetype: User's detected failure archetype
            strategic_goal: What we're trying to achieve
            
        Returns:
            (problem_metadata, reason_vector)
        """
        # Step 1: Determine target difficulty
        target_difficulty = self._compute_target_difficulty(
            user_profile.current_rating, 
            strategic_goal
        )
        
        # Step 2: Identify target skill
        target_skill = self._identify_weak_skill(user_profile)
        
        # Step 3: Filter candidates
        candidates = self._filter_candidates(
            target_difficulty=target_difficulty,
            target_skill=target_skill,
            target_archetype=current_archetype,
            user_profile=user_profile
        )
        
        if not candidates:
            # Fallback: any problem at target difficulty
            candidates = self._get_problems_near_difficulty(target_difficulty)
        
        # Step 4: Rank and select
        best_problem_id = self._rank_and_select(candidates, user_profile)
        
        if best_problem_id is None:
            # Ultimate fallback
            best_problem_id = random.choice(list(self.problems.keys()))
        
        problem = self.problems[best_problem_id]
        
        # Step 5: Build reason vector
        reason = self._build_reason_vector(
            problem=problem,
            user_profile=user_profile,
            target_skill=target_skill,
            current_archetype=current_archetype,
            strategic_goal=strategic_goal,
            target_difficulty=target_difficulty
        )
        
        return problem, reason
    
    def _compute_target_difficulty(self, current_rating: int, goal: str) -> int:
        """Compute optimal difficulty for user."""
        if goal == "break_through_plateau":
            return current_rating + 100  # Stretch
        elif goal == "build_confidence":
            return current_rating - 100  # Easier
        elif goal == "stabilize":
            return current_rating  # At-level
        else:  # optimal_growth
            return current_rating + 50  # Slight stretch
    
    def _identify_weak_skill(self, user_profile: UserSkillProfile) -> Optional[str]:
        """Identify user's weakest skill that needs work."""
        if user_profile.weak_skills:
            # Prioritize avoided skills
            for skill in user_profile.weak_skills:
                if skill in user_profile.avoided_tags:
                    return skill
            # Otherwise, pick any weak skill
            return list(user_profile.weak_skills)[0]
        return None
    
    def _filter_candidates(self, 
                          target_difficulty: int,
                          target_skill: Optional[str],
                          target_archetype: Optional[str],
                          user_profile: UserSkillProfile) -> List[int]:
        """Filter problems that match criteria."""
        candidates = set()
        
        # Start with difficulty range (Â±100 rating points)
        for diff_bucket in range(target_difficulty - 100, target_difficulty + 200, 100):
            if diff_bucket in self.by_difficulty:
                candidates.update(self.by_difficulty[diff_bucket])
        
        # Filter by skill if specified
        if target_skill and target_skill in self.by_tag:
            skill_problems = set(self.by_tag[target_skill])
            candidates = candidates.intersection(skill_problems)
        
        # Filter by archetype if specified
        if target_archetype and target_archetype in self.by_archetype:
            archetype_problems = set(self.by_archetype[target_archetype])
            candidates = candidates.intersection(archetype_problems)
        
        # Remove already completed problems
        already_solved = set(user_profile.recent_problems_solved)
        candidates = candidates - already_solved
        
        return list(candidates)
    
    def _get_problems_near_difficulty(self, target_difficulty: int) -> List[int]:
        """Get any problems near target difficulty."""
        problems = []
        for diff_bucket in range(target_difficulty - 200, target_difficulty + 300, 100):
            if diff_bucket in self.by_difficulty:
                problems.extend(self.by_difficulty[diff_bucket])
        return problems
    
    def _rank_and_select(self, candidates: List[int], 
                        user_profile: UserSkillProfile) -> Optional[int]:
        """Rank candidates and select best one."""
        if not candidates:
            return None
        
        # Simple scoring: prefer problems with multiple relevant tags
        def score_problem(pid: int) -> float:
            problem = self.problems[pid]
            score = 0.0
            
            # Bonus for targeting weak skills
            for tag in problem.tags:
                if tag in user_profile.weak_skills:
                    score += 2.0
                if tag in user_profile.avoided_tags:
                    score += 3.0  # Extra bonus for confronting fears
            
            # Bonus for cognitive triggers
            score += len(problem.cognitive_triggers) * 0.5
            
            # Penalty for very long problems
            if problem.typical_solve_time_minutes > 90:
                score -= 1.0
            
            return score
        
        # Sort by score and pick best
        scored = [(pid, score_problem(pid)) for pid in candidates]
        scored.sort(key=lambda x: x[1], reverse=True)
        
        return scored[0][0] if scored else None
    
    def _build_reason_vector(self,
                            problem: ProblemMetadata,
                            user_profile: UserSkillProfile,
                            target_skill: Optional[str],
                            current_archetype: Optional[str],
                            strategic_goal: str,
                            target_difficulty: int) -> ReasonVector:
        """Build the complete reasoning for this assignment."""
        
        difficulty_gap = problem.difficulty - user_profile.current_rating
        
        # Determine if this targets a weak skill
        weak_skill_match = any(tag in user_profile.weak_skills 
                              for tag in problem.tags)
        
        # Trajectory alignment (simplified)
        trajectory_phase = user_profile.trajectory_phase
        if trajectory_phase == "foundation":
            trajectory = "building_fundamentals"
        elif trajectory_phase == "growth":
            trajectory = "active_growth_phase"
        elif trajectory_phase == "mastery":
            trajectory = "mastery_refinement"
        else:
            trajectory = "expert_sharpening"
        
        # Difficulty justification
        if difficulty_gap > 100:
            diff_just = "stretch problem to break through current ceiling"
        elif difficulty_gap < -50:
            diff_just = "confidence builder to stabilize fundamentals"
        else:
            diff_just = "at-level problem for steady growth"
        
        # Archetype correction
        archetype_method = None
        if current_archetype and current_archetype in problem.failure_archetypes_targeted:
            archetype_method = f"Directly addresses {current_archetype} pattern"
        
        return ReasonVector(
            weak_skill_match=weak_skill_match,
            targeted_skill=target_skill,
            trajectory_alignment=trajectory,
            failure_archetype_targeted=current_archetype,
            archetype_correction_method=archetype_method,
            difficulty_gap=difficulty_gap,
            difficulty_justification=diff_just,
            similar_champion_problem=problem.historical_role,
            strategic_goal=strategic_goal
        )
    
    def generate_explanation(self, 
                           problem: ProblemMetadata, 
                           reason: ReasonVector,
                           use_gemini: bool = False) -> str:
        """
        Generate the "Why this problem?" explanation.
        
        This is what makes the system feel intelligent - it explains its reasoning.
        """
        if use_gemini and self.use_gemini:
            return self._generate_gemini_explanation(problem, reason)
        else:
            return self._generate_template_explanation(problem, reason)
    
    def _generate_template_explanation(self, 
                                      problem: ProblemMetadata,
                                      reason: ReasonVector) -> str:
        """Generate explanation using templates (no LLM)."""
        parts = []
        
        parts.append(f"ðŸŽ¯ **Why I'm giving you Problem {problem.problem_id} ({problem.title})**\n")
        
        # Skill targeting
        if reason.weak_skill_match and reason.targeted_skill:
            parts.append(
                f"ðŸ“š **Skill Gap**: You need more practice with `{reason.targeted_skill}`. "
                f"This problem specifically trains that weakness."
            )
        
        # Archetype correction
        if reason.archetype_correction_method:
            parts.append(
                f"ðŸŽ­ **Behavioral Pattern**: {reason.archetype_correction_method}"
            )
        
        # Difficulty reasoning
        if reason.difficulty_gap > 0:
            parts.append(
                f"ðŸ“ˆ **Growth Challenge**: This is +{reason.difficulty_gap} rating above your current level. "
                f"It's a {reason.difficulty_justification}."
            )
        else:
            parts.append(
                f"ðŸŽ¯ **Strategic Choice**: {reason.difficulty_justification}"
            )
        
        # Historical context
        if reason.similar_champion_problem:
            parts.append(
                f"ðŸ† **Champion Insight**: This is a {reason.similar_champion_problem}. "
                f"Top competitors faced similar challenges at this stage."
            )
        
        # Cognitive triggers
        if problem.cognitive_triggers:
            trigger_names = [t.value.replace('_', ' ').title() 
                           for t in problem.cognitive_triggers[:2]]
            parts.append(
                f"ðŸ§  **Mental Challenge**: This problem {', '.join(trigger_names).lower()}."
            )
        
        # Common pitfalls
        if problem.common_wrong_paths:
            parts.append(
                f"âš ï¸ **Watch Out**: Common mistakes include: {', '.join(problem.common_wrong_paths[:2])}."
            )
        
        return "\n\n".join(parts)
    
    def _generate_gemini_explanation(self,
                                    problem: ProblemMetadata,
                                    reason: ReasonVector) -> str:
        """Generate explanation using Gemini (more nuanced)."""
        # This would call Gemini with the reason vector
        # For now, fall back to template
        return self._generate_template_explanation(problem, reason)
    
    def get_problem(self, problem_id: int) -> Optional[ProblemMetadata]:
        """Get problem metadata by ID."""
        return self.problems.get(problem_id)
    
    def add_problem(self, problem: ProblemMetadata):
        """Add a new problem to the database."""
        self.problems[problem.problem_id] = problem
        # Rebuild indices
        self._build_indices()
